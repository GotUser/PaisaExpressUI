{"version":3,"file":"react-text-mask-hoc.ReactNative.js","sources":["../node_modules/text-mask-core/src/adjustCaretPosition.js","../node_modules/text-mask-core/src/constants.js","../node_modules/text-mask-core/src/utilities.js","../node_modules/text-mask-core/src/conformToMask.js","../src/TextMaskTransformer.js","../src/TextMask.js","../src/withTextMask.js","../src/TextInputAdapter.js","../src/TextAdapter.js"],"sourcesContent":["const defaultArray = []\nconst emptyString = ''\n\nexport default function adjustCaretPosition({\n  previousConformedValue = emptyString,\n  previousPlaceholder = emptyString,\n  currentCaretPosition = 0,\n  conformedValue,\n  rawValue,\n  placeholderChar,\n  placeholder,\n  indexesOfPipedChars = defaultArray,\n  caretTrapIndexes = defaultArray\n}) {\n  if (currentCaretPosition === 0) { return 0 }\n\n  // Store lengths for faster performance?\n  const rawValueLength = rawValue.length\n  const previousConformedValueLength = previousConformedValue.length\n  const placeholderLength = placeholder.length\n  const conformedValueLength = conformedValue.length\n\n  // This tells us how long the edit is. If user modified input from `(2__)` to `(243__)`,\n  // we know the user in this instance pasted two characters\n  const editLength = rawValueLength - previousConformedValueLength\n\n  // If the edit length is positive, that means the user is adding characters, not deleting.\n  const isAddition = editLength > 0\n\n  // This is the first raw value the user entered that needs to be conformed to mask\n  const isFirstRawValue = previousConformedValueLength === 0\n\n  // A partial multi-character edit happens when the user makes a partial selection in their\n  // input and edits that selection. That is going from `(123) 432-4348` to `() 432-4348` by\n  // selecting the first 3 digits and pressing backspace.\n  //\n  // Such cases can also happen when the user presses the backspace while holding down the ALT\n  // key.\n  const isPartialMultiCharEdit = editLength > 1 && !isAddition && !isFirstRawValue\n\n  // This algorithm doesn't support all cases of multi-character edits, so we just return\n  // the current caret position.\n  //\n  // This works fine for most cases.\n  if (isPartialMultiCharEdit) { return currentCaretPosition }\n\n  // For a mask like (111), if the `previousConformedValue` is (1__) and user attempts to enter\n  // `f` so the `rawValue` becomes (1f__), the new `conformedValue` would be (1__), which is the\n  // same as the original `previousConformedValue`. We handle this case differently for caret\n  // positioning.\n  const possiblyHasRejectedChar = isAddition && (\n    previousConformedValue === conformedValue ||\n    conformedValue === placeholder\n  )\n\n  let startingSearchIndex = 0\n  let trackRightCharacter\n  let targetChar\n\n  if (possiblyHasRejectedChar) {\n    startingSearchIndex = currentCaretPosition - editLength\n  } else {\n    // At this point in the algorithm, we want to know where the caret is right before the raw input\n    // has been conformed, and then see if we can find that same spot in the conformed input.\n    //\n    // We do that by seeing what character lies immediately before the caret, and then look for that\n    // same character in the conformed input and place the caret there.\n\n    // First, we need to normalize the inputs so that letter capitalization between raw input and\n    // conformed input wouldn't matter.\n    const normalizedConformedValue = conformedValue.toLowerCase()\n    const normalizedRawValue = rawValue.toLowerCase()\n\n    // Then we take all characters that come before where the caret currently is.\n    const leftHalfChars = normalizedRawValue.substr(0, currentCaretPosition).split(emptyString)\n\n    // Now we find all the characters in the left half that exist in the conformed input\n    // This step ensures that we don't look for a character that was filtered out or rejected by `conformToMask`.\n    const intersection = leftHalfChars.filter((char) => normalizedConformedValue.indexOf(char) !== -1)\n\n    // The last character in the intersection is the character we want to look for in the conformed\n    // value and the one we want to adjust the caret close to\n    targetChar = intersection[intersection.length - 1]\n\n    // Calculate the number of mask characters in the previous placeholder\n    // from the start of the string up to the place where the caret is\n    const previousLeftMaskChars = previousPlaceholder\n      .substr(0, intersection.length)\n      .split(emptyString)\n      .filter(char => char !== placeholderChar)\n      .length\n\n    // Calculate the number of mask characters in the current placeholder\n    // from the start of the string up to the place where the caret is\n    const leftMaskChars = placeholder\n      .substr(0, intersection.length)\n      .split(emptyString)\n      .filter(char => char !== placeholderChar)\n      .length\n\n    // Has the number of mask characters up to the caret changed?\n    const masklengthChanged = leftMaskChars !== previousLeftMaskChars\n\n    // Detect if `targetChar` is a mask character and has moved to the left\n    const targetIsMaskMovingLeft = (\n      previousPlaceholder[intersection.length - 1] !== undefined &&\n      placeholder[intersection.length - 2] !== undefined &&\n      previousPlaceholder[intersection.length - 1] !== placeholderChar &&\n      previousPlaceholder[intersection.length - 1] !== placeholder[intersection.length - 1] &&\n      previousPlaceholder[intersection.length - 1] === placeholder[intersection.length - 2]\n    )\n\n    // If deleting and the `targetChar` `is a mask character and `masklengthChanged` is true\n    // or the mask is moving to the left, we can't use the selected `targetChar` any longer\n    // if we are not at the end of the string.\n    // In this case, change tracking strategy and track the character to the right of the caret.\n    if (\n      !isAddition &&\n      (masklengthChanged || targetIsMaskMovingLeft) &&\n      previousLeftMaskChars > 0 &&\n      placeholder.indexOf(targetChar) > -1 &&\n      rawValue[currentCaretPosition] !== undefined\n    ) {\n      trackRightCharacter = true\n      targetChar = rawValue[currentCaretPosition]\n    }\n\n    // It is possible that `targetChar` will appear multiple times in the conformed value.\n    // We need to know not to select a character that looks like our target character from the placeholder or\n    // the piped characters, so we inspect the piped characters and the placeholder to see if they contain\n    // characters that match our target character.\n\n    // If the `conformedValue` got piped, we need to know which characters were piped in so that when we look for\n    // our `targetChar`, we don't select a piped char by mistake\n    const pipedChars = indexesOfPipedChars.map((index) => normalizedConformedValue[index])\n\n    // We need to know how many times the `targetChar` occurs in the piped characters.\n    const countTargetCharInPipedChars = pipedChars.filter((char) => char === targetChar).length\n\n    // We need to know how many times it occurs in the intersection\n    const countTargetCharInIntersection = intersection.filter((char) => char === targetChar).length\n\n    // We need to know if the placeholder contains characters that look like\n    // our `targetChar`, so we don't select one of those by mistake.\n    const countTargetCharInPlaceholder = placeholder\n      .substr(0, placeholder.indexOf(placeholderChar))\n      .split(emptyString)\n      .filter((char, index) => (\n        // Check if `char` is the same as our `targetChar`, so we account for it\n        char === targetChar &&\n\n        // but also make sure that both the `rawValue` and placeholder don't have the same character at the same\n        // index because if they are equal, that means we are already counting those characters in\n        // `countTargetCharInIntersection`\n        rawValue[index] !== char\n      ))\n      .length\n\n    // The number of times we need to see occurrences of the `targetChar` before we know it is the one we're looking\n    // for is:\n    const requiredNumberOfMatches = (\n      countTargetCharInPlaceholder +\n      countTargetCharInIntersection +\n      countTargetCharInPipedChars +\n      // The character to the right of the caret isn't included in `intersection`\n      // so add one if we are tracking the character to the right\n      (trackRightCharacter ? 1 : 0)\n    )\n\n    // Now we start looking for the location of the `targetChar`.\n    // We keep looping forward and store the index in every iteration. Once we have encountered\n    // enough occurrences of the target character, we break out of the loop\n    // If are searching for the second `1` in `1214`, `startingSearchIndex` will point at `4`.\n    let numberOfEncounteredMatches = 0\n    for (let i = 0; i < conformedValueLength; i++) {\n      const conformedValueChar = normalizedConformedValue[i]\n\n      startingSearchIndex = i + 1\n\n      if (conformedValueChar === targetChar) {\n        numberOfEncounteredMatches++\n      }\n\n      if (numberOfEncounteredMatches >= requiredNumberOfMatches) {\n        break\n      }\n    }\n  }\n\n  // At this point, if we simply return `startingSearchIndex` as the adjusted caret position,\n  // most cases would be handled. However, we want to fast forward or rewind the caret to the\n  // closest placeholder character if it happens to be in a non-editable spot. That's what the next\n  // logic is for.\n\n  // In case of addition, we fast forward.\n  if (isAddition) {\n    // We want to remember the last placeholder character encountered so that if the mask\n    // contains more characters after the last placeholder character, we don't forward the caret\n    // that far to the right. Instead, we stop it at the last encountered placeholder character.\n    let lastPlaceholderChar = startingSearchIndex\n\n    for (let i = startingSearchIndex; i <= placeholderLength; i++) {\n      if (placeholder[i] === placeholderChar) {\n        lastPlaceholderChar = i\n      }\n\n      if (\n        // If we're adding, we can position the caret at the next placeholder character.\n        placeholder[i] === placeholderChar ||\n\n        // If a caret trap was set by a mask function, we need to stop at the trap.\n        caretTrapIndexes.indexOf(i) !== -1 ||\n\n        // This is the end of the placeholder. We cannot move any further. Let's put the caret there.\n        i === placeholderLength\n      ) {\n        return lastPlaceholderChar\n      }\n    }\n  } else {\n    // In case of deletion, we rewind.\n    if (trackRightCharacter) {\n      // Searching for the character that was to the right of the caret\n      // We start at `startingSearchIndex` - 1 because it includes one character extra to the right\n      for (let i = startingSearchIndex - 1; i >= 0; i--) {\n        // If tracking the character to the right of the cursor, we move to the left until\n        // we found the character and then place the caret right before it\n\n        if (\n          // `targetChar` should be in `conformedValue`, since it was in `rawValue`, just\n          // to the right of the caret\n          conformedValue[i] === targetChar ||\n\n          // If a caret trap was set by a mask function, we need to stop at the trap.\n          caretTrapIndexes.indexOf(i) !== -1 ||\n\n          // This is the beginning of the placeholder. We cannot move any further.\n          // Let's put the caret there.\n          i === 0\n        ) {\n          return i\n        }\n      }\n    } else {\n      // Searching for the first placeholder or caret trap to the left\n\n      for (let i = startingSearchIndex; i >= 0; i--) {\n        // If we're deleting, we stop the caret right before the placeholder character.\n        // For example, for mask `(111) 11`, current conformed input `(456) 86`. If user\n        // modifies input to `(456 86`. That is, they deleted the `)`, we place the caret\n        // right after the first `6`\n\n        if (\n          // If we're deleting, we can position the caret right before the placeholder character\n          placeholder[i - 1] === placeholderChar ||\n\n          // If a caret trap was set by a mask function, we need to stop at the trap.\n          caretTrapIndexes.indexOf(i) !== -1 ||\n\n          // This is the beginning of the placeholder. We cannot move any further.\n          // Let's put the caret there.\n          i === 0\n        ) {\n          return i\n        }\n      }\n    }\n  }\n}\n","export const placeholderChar = '_'\n","import {placeholderChar as defaultPlaceholderChar} from './constants'\n\nconst emptyArray = []\n\nexport function convertMaskToPlaceholder(mask = emptyArray, placeholderChar = defaultPlaceholderChar) {\n  if (mask.indexOf(placeholderChar) !== -1) {\n    throw new Error(\n      'Placeholder character must not be used as part of the mask. Please specify a character ' +\n      'that is not present in your mask as your placeholder character.\\n\\n' +\n      `The placeholder character that was received is: ${JSON.stringify(placeholderChar)}\\n\\n` +\n      `The mask that was received is: ${JSON.stringify(mask)}`\n    )\n  }\n\n  return mask.map((char) => {\n    return (char instanceof RegExp) ? placeholderChar : char\n  }).join('')\n}\n\nexport function isString(value) {\n  return typeof value === 'string' || value instanceof String\n}\n\nexport function isNumber(value) {\n  return typeof value === 'number' && value.length === undefined && !isNaN(value)\n}\n\nconst strCaretTrap = '[]'\nexport function processCaretTraps(mask) {\n  const indexes = []\n\n  let indexOfCaretTrap\n  while(indexOfCaretTrap = mask.indexOf(strCaretTrap), indexOfCaretTrap !== -1) { // eslint-disable-line\n    indexes.push(indexOfCaretTrap)\n\n    mask.splice(indexOfCaretTrap, 1)\n  }\n\n  return {maskWithoutCaretTraps: mask, indexes}\n}\n","import {convertMaskToPlaceholder} from './utilities'\nimport {placeholderChar as defaultPlaceholderChar} from './constants'\n\nconst emptyString = ''\n\nexport default function conformToMask(rawValue = emptyString, mask = emptyString, config = {}) {\n  // These configurations tell us how to conform the mask\n  const {\n    guide = true,\n    previousConformedValue = emptyString,\n    placeholderChar = defaultPlaceholderChar,\n    placeholder = convertMaskToPlaceholder(mask, placeholderChar),\n    currentCaretPosition,\n    keepCharPositions\n  } = config\n\n  // The configs below indicate that the user wants the algorithm to work in *no guide* mode\n  const suppressGuide = guide === false && previousConformedValue !== undefined\n\n  // Calculate lengths once for performance\n  const rawValueLength = rawValue.length\n  const previousConformedValueLength = previousConformedValue.length\n  const placeholderLength = placeholder.length\n  const maskLength = mask.length\n\n  // This tells us the number of edited characters and the direction in which they were edited (+/-)\n  const editDistance = rawValueLength - previousConformedValueLength\n\n  // In *no guide* mode, we need to know if the user is trying to add a character or not\n  const isAddition = editDistance > 0\n\n  // Tells us the index of the first change. For (438) 394-4938 to (38) 394-4938, that would be 1\n  const indexOfFirstChange = currentCaretPosition + (isAddition ? -editDistance : 0)\n\n  // We're also gonna need the index of last change, which we can derive as follows...\n  const indexOfLastChange = indexOfFirstChange + Math.abs(editDistance)\n\n  // If `conformToMask` is configured to keep character positions, that is, for mask 111, previous value\n  // _2_ and raw value 3_2_, the new conformed value should be 32_, not 3_2 (default behavior). That's in the case of\n  // addition. And in the case of deletion, previous value _23, raw value _3, the new conformed string should be\n  // __3, not _3_ (default behavior)\n  //\n  // The next block of logic handles keeping character positions for the case of deletion. (Keeping\n  // character positions for the case of addition is further down since it is handled differently.)\n  // To do this, we want to compensate for all characters that were deleted\n  if (keepCharPositions === true && !isAddition) {\n    // We will be storing the new placeholder characters in this variable.\n    let compensatingPlaceholderChars = emptyString\n\n    // For every character that was deleted from a placeholder position, we add a placeholder char\n    for (let i = indexOfFirstChange; i < indexOfLastChange; i++) {\n      if (placeholder[i] === placeholderChar) {\n        compensatingPlaceholderChars += placeholderChar\n      }\n    }\n\n    // Now we trick our algorithm by modifying the raw value to make it contain additional placeholder characters\n    // That way when the we start laying the characters again on the mask, it will keep the non-deleted characters\n    // in their positions.\n    rawValue = (\n      rawValue.slice(0, indexOfFirstChange) +\n      compensatingPlaceholderChars +\n      rawValue.slice(indexOfFirstChange, rawValueLength)\n    )\n  }\n\n  // Convert `rawValue` string to an array, and mark characters based on whether they are newly added or have\n  // existed in the previous conformed value. Identifying new and old characters is needed for `conformToMask`\n  // to work if it is configured to keep character positions.\n  const rawValueArr = rawValue\n    .split(emptyString)\n    .map((char, i) => ({char, isNew: i >= indexOfFirstChange && i < indexOfLastChange}))\n\n  // The loop below removes masking characters from user input. For example, for mask\n  // `00 (111)`, the placeholder would be `00 (___)`. If user input is `00 (234)`, the loop below\n  // would remove all characters but `234` from the `rawValueArr`. The rest of the algorithm\n  // then would lay `234` on top of the available placeholder positions in the mask.\n  for (let i = rawValueLength - 1; i >= 0; i--) {\n    const {char} = rawValueArr[i]\n\n    if (char !== placeholderChar) {\n      const shouldOffset = i >= indexOfFirstChange && previousConformedValueLength === maskLength\n\n      if (char === placeholder[(shouldOffset) ? i - editDistance : i]) {\n        rawValueArr.splice(i, 1)\n      }\n    }\n  }\n\n  // This is the variable that we will be filling with characters as we figure them out\n  // in the algorithm below\n  let conformedValue = emptyString\n  let someCharsRejected = false\n\n  // Ok, so first we loop through the placeholder looking for placeholder characters to fill up.\n  placeholderLoop: for (let i = 0; i < placeholderLength; i++) {\n    const charInPlaceholder = placeholder[i]\n\n    // We see one. Let's find out what we can put in it.\n    if (charInPlaceholder === placeholderChar) {\n      // But before that, do we actually have any user characters that need a place?\n      if (rawValueArr.length > 0) {\n        // We will keep chipping away at user input until either we run out of characters\n        // or we find at least one character that we can map.\n        while (rawValueArr.length > 0) {\n          // Let's retrieve the first user character in the queue of characters we have left\n          const {char: rawValueChar, isNew} = rawValueArr.shift()\n\n          // If the character we got from the user input is a placeholder character (which happens\n          // regularly because user input could be something like (540) 90_-____, which includes\n          // a bunch of `_` which are placeholder characters) and we are not in *no guide* mode,\n          // then we map this placeholder character to the current spot in the placeholder\n          if (rawValueChar === placeholderChar && suppressGuide !== true) {\n            conformedValue += placeholderChar\n\n            // And we go to find the next placeholder character that needs filling\n            continue placeholderLoop\n\n          // Else if, the character we got from the user input is not a placeholder, let's see\n          // if the current position in the mask can accept it.\n          } else if (mask[i].test(rawValueChar)) {\n            // we map the character differently based on whether we are keeping character positions or not.\n            // If any of the conditions below are met, we simply map the raw value character to the\n            // placeholder position.\n            if (\n              keepCharPositions !== true ||\n              isNew === false ||\n              previousConformedValue === emptyString ||\n              guide === false ||\n              !isAddition\n            ) {\n              conformedValue += rawValueChar\n            } else {\n              // We enter this block of code if we are trying to keep character positions and none of the conditions\n              // above is met. In this case, we need to see if there's an available spot for the raw value character\n              // to be mapped to. If we couldn't find a spot, we will discard the character.\n              //\n              // For example, for mask `1111`, previous conformed value `_2__`, raw value `942_2__`. We can map the\n              // `9`, to the first available placeholder position, but then, there are no more spots available for the\n              // `4` and `2`. So, we discard them and end up with a conformed value of `92__`.\n              const rawValueArrLength = rawValueArr.length\n              let indexOfNextAvailablePlaceholderChar = null\n\n              // Let's loop through the remaining raw value characters. We are looking for either a suitable spot, ie,\n              // a placeholder character or a non-suitable spot, ie, a non-placeholder character that is not new.\n              // If we see a suitable spot first, we store its position and exit the loop. If we see a non-suitable\n              // spot first, we exit the loop and our `indexOfNextAvailablePlaceholderChar` will stay as `null`.\n              for (let i = 0; i < rawValueArrLength; i++) {\n                const charData = rawValueArr[i]\n\n                if (charData.char !== placeholderChar && charData.isNew === false) {\n                  break\n                }\n\n                if (charData.char === placeholderChar) {\n                  indexOfNextAvailablePlaceholderChar = i\n                  break\n                }\n              }\n\n              // If `indexOfNextAvailablePlaceholderChar` is not `null`, that means the character is not blocked.\n              // We can map it. And to keep the character positions, we remove the placeholder character\n              // from the remaining characters\n              if (indexOfNextAvailablePlaceholderChar !== null) {\n                conformedValue += rawValueChar\n                rawValueArr.splice(indexOfNextAvailablePlaceholderChar, 1)\n\n              // If `indexOfNextAvailablePlaceholderChar` is `null`, that means the character is blocked. We have to\n              // discard it.\n              } else {\n                i--\n              }\n            }\n\n            // Since we've mapped this placeholder position. We move on to the next one.\n            continue placeholderLoop\n          } else {\n            someCharsRejected = true\n          }\n        }\n      }\n\n      // We reach this point when we've mapped all the user input characters to placeholder\n      // positions in the mask. In *guide* mode, we append the left over characters in the\n      // placeholder to the `conformedString`, but in *no guide* mode, we don't wanna do that.\n      //\n      // That is, for mask `(111)` and user input `2`, we want to return `(2`, not `(2__)`.\n      if (suppressGuide === false) {\n        conformedValue += placeholder.substr(i, placeholderLength)\n      }\n\n      // And we break\n      break\n\n    // Else, the charInPlaceholder is not a placeholderChar. That is, we cannot fill it\n    // with user input. So we just map it to the final output\n    } else {\n      conformedValue += charInPlaceholder\n    }\n  }\n\n  // The following logic is needed to deal with the case of deletion in *no guide* mode.\n  //\n  // Consider the silly mask `(111) /// 1`. What if user tries to delete the last placeholder\n  // position? Something like `(589) /// `. We want to conform that to `(589`. Not `(589) /// `.\n  // That's why the logic below finds the last filled placeholder character, and removes everything\n  // from that point on.\n  if (suppressGuide && isAddition === false) {\n    let indexOfLastFilledPlaceholderChar = null\n\n    // Find the last filled placeholder position and substring from there\n    for (let i = 0; i < conformedValue.length; i++) {\n      if (placeholder[i] === placeholderChar) {\n        indexOfLastFilledPlaceholderChar = i\n      }\n    }\n\n    if (indexOfLastFilledPlaceholderChar !== null) {\n      // We substring from the beginning until the position after the last filled placeholder char.\n      conformedValue = conformedValue.substr(0, indexOfLastFilledPlaceholderChar + 1)\n    } else {\n      // If we couldn't find `indexOfLastFilledPlaceholderChar` that means the user deleted\n      // the first character in the mask. So we return an empty string.\n      conformedValue = emptyString\n    }\n  }\n\n  return {conformedValue, meta: {someCharsRejected}}\n}\n","import adjustCaretPosition from 'text-mask-core/src/adjustCaretPosition';\nimport conformToMask from 'text-mask-core/src/conformToMask';\nimport {convertMaskToPlaceholder, isString, isNumber, processCaretTraps} from 'text-mask-core/src/utilities';\nimport {placeholderChar as defaultPlaceholderChar} from 'text-mask-core/src/constants';\n\nfunction getSafeRawValue(inputValue) {\n    if (inputValue == null) return '';\n    if (isString(inputValue)) return inputValue;\n    if (isNumber(inputValue)) return String(inputValue);\n\n    throw new Error(\n        \"The 'value' provided to Text Mask needs to be a string or a number. The value \" +\n            `received was:\\n\\n ${JSON.stringify(inputValue)}`\n    );\n}\n\nexport default class TextMaskTransformer {\n    previousConformedValue = undefined;\n    previousPlaceholder = undefined;\n\n    update({\n        value: rawValue,\n        caretPosition: currentCaretPosition,\n        mask: providedMask,\n        guide,\n        pipe,\n        placeholderChar = defaultPlaceholderChar,\n        keepCharPositions = false,\n        showMask = false,\n    }) {\n        // If `rawValue` equals `state.previousConformedValue`, we don't need to change anything. So, we return.\n        // This check is here to handle controlled framework components that repeat the `update` call on every render.\n        if (rawValue === this.previousConformedValue) {\n            return null;\n        }\n\n        // Text Mask accepts masks that are a combination of a `mask` and a `pipe` that work together.\n        // If such a `mask` is passed, we destructure it below, so the rest of the code can work normally\n        // as if a separate `mask` and a `pipe` were passed.\n        if (\n            providedMask != null &&\n            typeof providedMask === 'object' &&\n            providedMask.pipe != null &&\n            providedMask.mask != null\n        ) {\n            /* eslint-disable no-param-reassign, prefer-destructuring */\n            pipe = providedMask.pipe;\n            providedMask = providedMask.mask;\n            /* eslint-enable */\n        }\n\n        // The `placeholder` is an essential piece of how Text Mask works. For a mask like `(111)`,\n        // the placeholder would be `(___)` if the `placeholderChar` is set to `_`.\n        let placeholder;\n\n        // We don't know what the mask would be yet. If it is an array, we take it as is, but if it's a function,\n        // we will have to call that function to get the mask array.\n        let mask;\n\n        // If the provided mask is an array, we can call `convertMaskToPlaceholder` here once and we'll always have the\n        // correct `placeholder`.\n        if (Array.isArray(providedMask)) {\n            placeholder = convertMaskToPlaceholder(providedMask, placeholderChar);\n        }\n\n        // We check the provided `rawValue` before moving further.\n        // If it's something we can't work with `getSafeRawValue` will throw.\n        const safeRawValue = getSafeRawValue(rawValue);\n\n        // In framework components that support reactivity, it's possible to turn off masking by passing\n        // `false` for `mask` after initialization. See https://github.com/text-mask/text-mask/pull/359\n        if (providedMask === false) {\n            return {\n                value: safeRawValue,\n                caretPosition: currentCaretPosition,\n            };\n        }\n\n        let caretTrapIndexes;\n\n        // If the `providedMask` is a function. We need to call it at every `update` to get the `mask` array.\n        // Then we also need to get the `placeholder`\n        if (typeof providedMask === 'function') {\n            mask = providedMask(safeRawValue, {\n                currentCaretPosition,\n                previousConformedValue: this.previousConformedValue,\n                placeholderChar,\n            });\n\n            // disable masking if `mask` is `false`\n            if (mask === false) {\n                return null;\n            }\n\n            // mask functions can setup caret traps to have some control over how the caret moves. We need to process\n            // the mask for any caret traps. `processCaretTraps` will remove the caret traps from the mask and return\n            // the indexes of the caret traps.\n            const {maskWithoutCaretTraps, indexes} = processCaretTraps(mask);\n\n            // The processed mask is what we're interested in\n            mask = maskWithoutCaretTraps;\n            // And we need to store these indexes because they're needed by `adjustCaretPosition`\n            caretTrapIndexes = indexes;\n\n            placeholder = convertMaskToPlaceholder(mask, placeholderChar);\n\n            // If the `providedMask` is not a function, we just use it as-is.\n        }\n        else {\n            mask = providedMask;\n        }\n\n        // The following object will be passed to `conformToMask` to determine how the `rawValue` will be conformed\n        const conformToMaskConfig = {\n            previousConformedValue: this.previousConformedValue,\n            guide,\n            placeholderChar,\n            pipe,\n            placeholder,\n            currentCaretPosition,\n            keepCharPositions,\n        };\n\n        // `conformToMask` returns `conformedValue` as part of an object for future API flexibility\n        const {conformedValue} = conformToMask(safeRawValue, mask, conformToMaskConfig);\n\n        // The following few lines are to support the `pipe` feature.\n        const piped = typeof pipe === 'function';\n\n        let pipeResults = {};\n\n        // If `pipe` is a function, we call it.\n        if (piped) {\n            // `pipe` receives the `conformedValue` and the configurations with which `conformToMask` was called.\n            pipeResults = pipe(conformedValue, {rawValue: safeRawValue, ...conformToMaskConfig});\n\n            // `pipeResults` should be an object. But as a convenience, we allow the pipe author to just\n            // return `false` to indicate rejection. Or return just a string when there are no piped characters.\n            // If the `pipe` returns `false` or a string, the block below turns it into an object that the rest\n            // of the code can work with.\n            if (pipeResults === false) {\n                // If the `pipe` rejects `conformedValue`, we use the `previousConformedValue`,\n                // and set `rejected` to `true`.\n                pipeResults = {value: this.previousConformedValue, rejected: true};\n            }\n            else if (isString(pipeResults)) {\n                pipeResults = {value: pipeResults};\n            }\n        }\n\n        // Before we proceed, we need to know which conformed value to use, the one returned by the pipe or the one\n        // returned by `conformToMask`.\n        const finalConformedValue = piped ? pipeResults.value : conformedValue;\n\n        // After determining the conformed value, we will need to know where to set\n        // the caret position. `adjustCaretPosition` will tell us.\n        const adjustedCaretPosition = adjustCaretPosition({\n            previousConformedValue: this.previousConformedValue,\n            previousPlaceholder: this.previousPlaceholder,\n            conformedValue: finalConformedValue,\n            placeholder,\n            rawValue: safeRawValue,\n            currentCaretPosition,\n            placeholderChar,\n            indexesOfPipedChars: pipeResults.indexesOfPipedChars,\n            caretTrapIndexes,\n        });\n\n        // Text Mask sets the input value to an empty string when the condition below is set. It provides a better UX.\n        const inputValueShouldBeEmpty = finalConformedValue === placeholder && adjustedCaretPosition === 0;\n        const emptyValue = showMask ? placeholder : '';\n        const inputElementValue = inputValueShouldBeEmpty ? emptyValue : finalConformedValue;\n\n        this.previousConformedValue = inputElementValue; // store value for access for next time\n        this.previousPlaceholder = placeholder;\n\n        return {\n            value: inputElementValue,\n            caretPosition: adjustedCaretPosition,\n        };\n    }\n}\n","import React, {PureComponent} from 'react';\nimport PropTypes from 'prop-types';\nimport {propsEqual} from 'react-shallow-equal';\nimport TextMaskTransformer from './TextMaskTransformer';\n\nexport default class TextMask extends PureComponent {\n    static propTypes = {\n        Component: PropTypes.func, // eslint-disable-line react/require-default-props\n        mask: PropTypes.oneOfType([\n            PropTypes.array,\n            PropTypes.func,\n            PropTypes.bool,\n            PropTypes.shape({\n                mask: PropTypes.oneOfType([PropTypes.array, PropTypes.func]),\n                pipe: PropTypes.func,\n            }),\n        ]).isRequired,\n        value: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n        isControlled: PropTypes.bool,\n        guide: PropTypes.bool,\n        pipe: PropTypes.func,\n        placeholderChar: PropTypes.string,\n        keepCharPositions: PropTypes.bool,\n        showMask: PropTypes.bool,\n        onChange: PropTypes.func,\n        componentRef: PropTypes.func,\n    };\n\n    static defaultProps = {\n        value: null,\n        isControlled: true,\n        guide: true,\n        pipe: null,\n        placeholderChar: '_',\n        keepCharPositions: false,\n        showMask: false,\n        onChange: () => {},\n        componentRef: () => {},\n    };\n\n    constructor(props, context) {\n        super(props, context);\n\n        this.component = null;\n        this.textMaskTransformer = new TextMaskTransformer();\n\n        const value = props.value != null ? props.value : '';\n        const nextUpdate = this._update({...props, value});\n\n        if (nextUpdate !== null) {\n            this.state = {\n                value: nextUpdate.value,\n                caretPosition: nextUpdate.caretPosition,\n            };\n        }\n        else {\n            this.state = {\n                value: '',\n                caretPosition: 0,\n            };\n        }\n    }\n\n    componentWillReceiveProps(nextProps) {\n        const ignore = [];\n\n        if (nextProps.isControlled === false) {\n            ignore.push('value');\n        }\n\n        if (!propsEqual(this.props, nextProps, {ignore})) {\n            const value =\n                nextProps.isControlled === true && nextProps.value != null ? nextProps.value : this.state.value;\n            const nextUpdate = this._update({...nextProps, value});\n            if (nextUpdate !== null) {\n                this.setState(nextUpdate);\n            }\n        }\n    }\n\n    get value() {\n        return this.state.value;\n    }\n\n    _update = props =>\n        this.textMaskTransformer.update({\n            value: props.value,\n            caretPosition: this.component != null ? this.component.caretPosition : 0,\n            mask: props.mask,\n            guide: props.guide,\n            pipe: props.pipe,\n            placeholderChar: props.placeholderChar,\n            keepCharPositions: props.keepCharPositions,\n            showMask: props.showMask,\n        });\n\n    _getRef = (comp) => {\n        if (comp) {\n            this.props.componentRef(comp);\n            this.component = comp;\n        }\n    };\n\n    _onChange = (event) => {\n        if (event) {\n            const rawValue = typeof event.target === 'object' ? event.target.value : event.text;\n            const nextUpdate = this._update({...this.props, value: rawValue});\n\n            if (nextUpdate !== null) {\n                this.setState(nextUpdate, () => {\n                    this.props.onChange(event, nextUpdate);\n                });\n            }\n            else {\n                this.props.onChange(event, this.state);\n                this.forceUpdate();\n            }\n        }\n    };\n\n    focus() {\n        if (this.component.input) this.component.input.focus();\n    }\n\n    blur() {\n        if (this.component.input) this.component.input.blur();\n    }\n\n    render() {\n        const {\n            Component,\n            value,\n            isControlled,\n            mask,\n            guide,\n            pipe,\n            placeholderChar,\n            keepCharPositions,\n            showMask,\n            componentRef,\n            onChange,\n            ...rest\n        } = this.props;\n\n        return (\n            <Component\n                {...rest}\n                value={this.state.value}\n                caretPosition={this.state.caretPosition}\n                onChange={this._onChange}\n                ref={this._getRef}\n            />\n        );\n    }\n}\n","import hoistStatics from 'hoist-non-react-statics';\nimport TextMask from './TextMask';\n\nconst getDisplayName = Comp => Comp.displayName || Comp.name || 'Unknown';\n\nexport default function withTextMask(AdaptedComponent) {\n    class TextMaskWrapper extends TextMask {\n        static displayName = `TextMask(${getDisplayName(AdaptedComponent)})`;\n\n        static defaultProps = {\n            ...TextMask.defaultProps,\n            Component: AdaptedComponent,\n        };\n    }\n\n    return hoistStatics(TextMaskWrapper, AdaptedComponent);\n}\n","import React, {Component} from 'react';\nimport {TextInput} from 'react-native'; // eslint-disable-line\nimport PropTypes from 'prop-types';\nimport {propsEqual} from 'react-shallow-equal';\n\nexport default class TextInputAdapter extends Component {\n    static propTypes = {\n        value: PropTypes.string.isRequired,\n        caretPosition: PropTypes.number.isRequired,\n        onChange: PropTypes.func.isRequired,\n    };\n\n    componentDidMount() {\n        this._setNativeProps(this.props.value, this.props.caretPosition);\n    }\n\n    componentWillReceiveProps(nextProps) {\n        this._setNativeProps(nextProps.value, nextProps.caretPosition);\n    }\n\n    shouldComponentUpdate(nextProps) {\n        return !propsEqual(this.props, nextProps, {\n            ignore: ['value', 'caretPosition'],\n        });\n    }\n\n    get caretPosition() {\n        return this._selection || 0;\n    }\n\n    _selection;\n    _lastOnChangeEvent;\n\n    _setNativeProps(value, caretPosition) {\n        this.input.setNativeProps({text: value});\n        this.input.setNativeProps({selection: {start: caretPosition, end: caretPosition}});\n    }\n\n    _getRef = (ref) => {\n        this.input = ref;\n    };\n\n    _onChange = ({nativeEvent}) => {\n        this._lastOnChangeEvent = nativeEvent;\n    };\n\n    // onChange() runs before onSelectionChange(), so when text-mask gets selection\n    // it's a previous value instead of the current one.\n    _onSelectionChange = (event) => {\n        this._selection = event.nativeEvent.selection.end;\n\n        if (this._lastOnChangeEvent) {\n            this.props.onChange(this._lastOnChangeEvent);\n            this._lastOnChangeEvent = undefined;\n        }\n    };\n\n    render() {\n        const {value, caretPosition, onChange, ...rest} = this.props;\n\n        return (\n            <TextInput\n                {...rest}\n                ref={this._getRef}\n                onChange={this._onChange}\n                onSelectionChange={this._onSelectionChange}\n            />\n        );\n    }\n}\n","import React, {PureComponent} from 'react';\nimport {Text} from 'react-native'; // eslint-disable-line\nimport PropTypes from 'prop-types';\n\nexport default class TextAdapter extends PureComponent {\n    static propTypes = {\n        value: PropTypes.string.isRequired,\n        caretPosition: PropTypes.number.isRequired,\n        onChange: PropTypes.func.isRequired,\n    };\n\n    // eslint-disable-next-line class-methods-use-this\n    get caretPosition() {\n        return 0;\n    }\n\n    render() {\n        const {value, caretPosition, onChange, ...rest} = this.props;\n\n        return <Text {...rest}>{value}</Text>;\n    }\n}\n"],"names":["defaultArray","emptyString","adjustCaretPosition","previousConformedValue","previousPlaceholder","currentCaretPosition","conformedValue","rawValue","placeholderChar","placeholder","indexesOfPipedChars","caretTrapIndexes","rawValueLength","length","previousConformedValueLength","placeholderLength","conformedValueLength","editLength","isAddition","isFirstRawValue","isPartialMultiCharEdit","possiblyHasRejectedChar","startingSearchIndex","trackRightCharacter","targetChar","normalizedConformedValue","toLowerCase","normalizedRawValue","leftHalfChars","substr","split","intersection","filter","char","indexOf","previousLeftMaskChars","leftMaskChars","masklengthChanged","targetIsMaskMovingLeft","undefined","pipedChars","map","index","countTargetCharInPipedChars","countTargetCharInIntersection","countTargetCharInPlaceholder","requiredNumberOfMatches","numberOfEncounteredMatches","i","conformedValueChar","lastPlaceholderChar","emptyArray","convertMaskToPlaceholder","mask","defaultPlaceholderChar","Error","JSON","stringify","RegExp","join","isString","value","String","isNumber","isNaN","strCaretTrap","processCaretTraps","indexes","indexOfCaretTrap","push","splice","conformToMask","config","guide","keepCharPositions","suppressGuide","maskLength","editDistance","indexOfFirstChange","indexOfLastChange","Math","abs","compensatingPlaceholderChars","slice","rawValueArr","shouldOffset","someCharsRejected","charInPlaceholder","shift","rawValueChar","isNew","placeholderLoop","test","rawValueArrLength","indexOfNextAvailablePlaceholderChar","charData","indexOfLastFilledPlaceholderChar","getSafeRawValue","inputValue","TextMaskTransformer","caretPosition","providedMask","pipe","showMask","babelHelpers.typeof","Array","isArray","safeRawValue","maskWithoutCaretTraps","conformToMaskConfig","piped","pipeResults","finalConformedValue","adjustedCaretPosition","inputValueShouldBeEmpty","emptyValue","inputElementValue","TextMask","props","context","component","textMaskTransformer","nextUpdate","_update","state","nextProps","ignore","isControlled","propsEqual","setState","input","focus","blur","Component","componentRef","onChange","rest","_onChange","_getRef","PureComponent","PropTypes","func","oneOfType","array","bool","shape","isRequired","string","number","update","comp","event","target","text","forceUpdate","getDisplayName","Comp","displayName","name","withTextMask","AdaptedComponent","TextMaskWrapper","defaultProps","hoistStatics","TextInputAdapter","ref","nativeEvent","_lastOnChangeEvent","_selection","selection","end","_setNativeProps","setNativeProps","_onSelectionChange","TextAdapter"],"mappings":"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"}