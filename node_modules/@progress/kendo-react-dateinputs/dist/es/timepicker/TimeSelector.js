var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
import * as React from 'react';
import * as PropTypes from 'prop-types';
import { cloneDate } from '@progress/kendo-date-math';
import { classNames, Keys } from '@progress/kendo-react-common';
import { provideIntlService, registerForIntl } from '@progress/kendo-react-intl';
import { TimeList } from './TimeList';
import { MIDNIGHT_DATE, MIN_TIME, MAX_TIME } from '../utils';
import { TIME_PART } from './models/TimePart';
import { generateGetters, generateSnappers, getNow, isInTimeRange, snapTime, timeInRange, valueMerger } from './utils';
var formatRegExp = new RegExp(TIME_PART.hour + "|" + TIME_PART.minute + "|" + TIME_PART.second + "|" + TIME_PART.dayperiod + "|literal");
/**
 * @hidden
 */
export var Direction;
(function (Direction) {
    Direction[Direction["Left"] = 0] = "Left";
    Direction[Direction["Right"] = 1] = "Right";
})(Direction || (Direction = {}));
/**
 * @hidden
 */
var TimeSelector = /** @class */ (function (_super) {
    __extends(TimeSelector, _super);
    function TimeSelector(props) {
        var _this = _super.call(this, props) || this;
        _this.timeLists = [];
        _this.focusActiveList = function () {
            var timeList = _this.timeLists[0];
            if ((_this.state.activeListIndex === -1) && !_this.hasActiveButton() && timeList && timeList.element) {
                timeList.element.focus();
            }
        };
        _this.focusList = function (dir) {
            if (!_this.timeLists.length) {
                return;
            }
            _this.timeLists.reduce(_this.listReducer, ([]))
                .map(function (state) { return dir === Direction.Right ? state.next : state.prev; })
                .map(function (list) { return list && list.element && list.element.focus(); });
        };
        _this.listReducer = function (state, list, idx, all) {
            if (state.length || list.props.id !== _this.state.activeListIndex) {
                return state;
            }
            return [{
                    next: all[idx + 1] || list,
                    prev: all[idx - 1] || list
                }];
        };
        _this.showNowButton = function () {
            return !_this.hasSteps() && _this.props.nowButton && isInTimeRange(getNow(), _this.min, _this.max);
        };
        _this.handleKeyDown = function (event) {
            var keyCode = event.keyCode;
            switch (keyCode) {
                case Keys.enter:
                    if (!_this.hasActiveButton()) {
                        _this.handleAccept(event);
                    }
                    return;
                case Keys.left:
                    event.preventDefault();
                    _this.focusList(Direction.Left);
                    return;
                case Keys.right:
                    event.preventDefault();
                    _this.focusList(Direction.Right);
                    return;
                default:
                    return;
            }
        };
        _this.handleAccept = function (event) {
            var value = _this.mergeValue(cloneDate(_this.value || getNow()), _this.current);
            _this.setState({ value: value });
            _this.valueDuringOnChange = value;
            var onChange = _this.props.onChange;
            if (onChange) {
                onChange.call(undefined, {
                    syntheticEvent: event,
                    nativeEvent: event.nativeEvent,
                    value: _this.value,
                    target: _this
                });
            }
            _this.valueDuringOnChange = undefined;
        };
        _this.handleReject = function (event) {
            var current = timeInRange(_this.snapTime(cloneDate(_this.value || MIDNIGHT_DATE)), _this.min, _this.max);
            _this.setState({ current: current });
            var onReject = _this.props.onReject;
            if (onReject) {
                onReject.call(undefined, event);
            }
        };
        _this.handleListBlur = function () {
            _this.nextTick(function () {
                _this.setState({ activeListIndex: -1 });
            });
        };
        _this.handleListFocus = function (idx) {
            clearTimeout(_this.nextTickId);
            _this.setState({
                activeListIndex: idx
            });
        };
        _this.handleNowClick = function (event) {
            var now = _this.mergeValue(cloneDate(_this.current), getNow());
            _this.setState({
                current: now,
                value: now
            });
            _this.valueDuringOnChange = now;
            var onChange = _this.props.onChange;
            if (onChange) {
                onChange.call(undefined, {
                    syntheticEvent: event,
                    nativeEvent: event.nativeEvent,
                    value: _this.value,
                    target: _this
                });
            }
            _this.valueDuringOnChange = undefined;
        };
        _this.handleChange = function (candidate) {
            var value = timeInRange(_this.snapTime(cloneDate(candidate || MIDNIGHT_DATE)), _this.min, _this.max);
            _this.setState({ current: value });
        };
        _this.dateFormatParts = _this.intl.splitDateFormat(_this.props.format || TimeSelector.defaultProps.format);
        _this.mergeValue = valueMerger(generateGetters(_this.dateFormatParts));
        _this.snapTime = snapTime(generateSnappers(_this.props.steps, _this.props.min || TimeSelector.defaultProps.min));
        var initialValue = timeInRange(_this.snapTime(cloneDate(_this.props.value || MIDNIGHT_DATE)), _this.min, _this.max);
        _this.state = {
            value: _this.props.value || TimeSelector.defaultProps.value,
            current: initialValue,
            min: _this.min,
            max: _this.max,
            activeListIndex: -1
        };
        _this.hasActiveButton = _this.hasActiveButton.bind(_this);
        return _this;
    }
    Object.defineProperty(TimeSelector.prototype, "element", {
        /**
         * @hidden
         */
        get: function () {
            return this._element;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeSelector.prototype, "value", {
        get: function () {
            var value = this.valueDuringOnChange !== undefined
                ? this.valueDuringOnChange
                : this.props.value !== undefined
                    ? this.props.value
                    : this.state.value;
            return (value !== null)
                ? cloneDate(value)
                : null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeSelector.prototype, "intl", {
        get: function () {
            return provideIntlService(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeSelector.prototype, "current", {
        get: function () {
            return cloneDate(this.state.current);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeSelector.prototype, "min", {
        get: function () {
            return this.snapTime(this.props.min || TimeSelector.defaultProps.min);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeSelector.prototype, "max", {
        get: function () {
            return this.snapTime(this.props.max || TimeSelector.defaultProps.max);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeSelector.prototype, "steps", {
        get: function () {
            return this.props.steps || TimeSelector.defaultProps.steps;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    TimeSelector.prototype.componentWillReceiveProps = function (nextProps) {
        if (nextProps.steps !== this.steps || nextProps.min !== this.min) {
            this.snapTime = snapTime(generateSnappers(nextProps.steps, nextProps.min));
        }
    };
    /**
     * @hidden
     */
    TimeSelector.prototype.componentWillUnmount = function () {
        clearTimeout(this.nextTickId);
    };
    /**
     * @hidden
     */
    TimeSelector.prototype.render = function () {
        var _this = this;
        var _a = this.props, format = _a.format, cancelButton = _a.cancelButton, disabled = _a.disabled, tabIndex = _a.tabIndex, className = _a.className, smoothScroll = _a.smoothScroll;
        this.timeLists = [];
        return (React.createElement("span", { ref: function (el) { _this._element = el; }, tabIndex: !disabled ? tabIndex || 0 : undefined, className: classNames('k-timeselector k-reset', className, {
                'k-state-disabled': disabled
            }), onKeyDown: this.handleKeyDown },
            React.createElement("div", { className: "k-time-header" },
                React.createElement("span", { className: "k-title" }, this.intl.formatDate(this.current, format)),
                this.showNowButton() &&
                    React.createElement("button", __assign({ ref: function (btn) { _this._nowButton = btn; }, className: "k-button k-bare k-time-now", title: "Select Now" }, { 'aria-label': 'Select Now' }, { onClick: this.handleNowClick }), "NOW")),
            React.createElement("div", { className: "k-time-list-container" },
                React.createElement("span", { className: "k-time-highlight" }),
                this.dateFormatParts.map(function (part, idx) {
                    return (part.type !== 'literal'
                        ? React.createElement("div", { key: idx, className: classNames('k-time-list-wrapper', {
                                'k-state-focused': idx === _this.state.activeListIndex
                            }), role: "presentation", tabIndex: -1 },
                            React.createElement("span", { className: "k-title", onMouseDown: function (e) { e.preventDefault(); } }, _this.intl.dateFieldName(part)),
                            React.createElement(TimeList, { min: _this.min, max: _this.max, part: part, step: part.type ? _this.steps[part.type] : 1, smoothScroll: smoothScroll, ref: function (el) { if (!el) {
                                    return;
                                } _this.timeLists.push(el); }, id: idx, onFocus: function () { _this.handleListFocus(idx); }, onBlur: _this.handleListBlur, onChange: _this.handleChange, value: _this.current }))
                        : React.createElement("div", { key: idx, className: "k-time-separator" }, part.pattern));
                })),
            React.createElement("div", { className: "k-time-footer k-action-buttons" },
                cancelButton &&
                    React.createElement("button", __assign({ ref: function (btn) { _this._cancelButton = btn; }, className: "k-button k-time-cancel", onClick: this.handleReject, title: "Cancel" }, { 'aria-label': 'Cancel' }), "Cancel"),
                React.createElement("button", __assign({ ref: function (btn) { _this._acceptButton = btn; }, className: "k-time-accept k-button k-primary", onClick: this.handleAccept, title: "Set" }, { 'aria-label': 'Set' }), "Set"))));
    };
    TimeSelector.prototype.nextTick = function (f) {
        // XXX: use setTimeout due to async focus/blur events in IE, and missing relatedTarget prop.
        // XXX: https://github.com/facebook/react/issues/3751
        clearTimeout(this.nextTickId);
        this.nextTickId = setTimeout(function () { return f(); });
    };
    TimeSelector.prototype.hasActiveButton = function () {
        if (!this._acceptButton) {
            return false;
        }
        return document.activeElement === this._acceptButton
            || document.activeElement === this._cancelButton
            || document.activeElement === this._nowButton;
    };
    TimeSelector.prototype.hasSteps = function () {
        var _this = this;
        var keys = Object.keys(this.steps);
        return keys.length !== keys.reduce(function (acc, k) { return acc + _this.steps[k]; }, 0);
    };
    TimeSelector.propTypes = {
        cancelButton: PropTypes.bool,
        className: PropTypes.string,
        disabled: PropTypes.bool,
        format: function (props, propName, componentName) {
            var prop = props[propName];
            var intl = provideIntlService(this);
            var dateFormatParts = intl.splitDateFormat(prop);
            dateFormatParts.forEach(function (part) {
                if (!formatRegExp.test(part.type)) {
                    throw new Error("\n                    Invalid prop '" + propName + "' supplied to " + componentName + ".\n                    Provided format is not supported. Supported specifiers are T|t|H|h|m|s|a.\n                ");
                }
            });
        },
        max: PropTypes.instanceOf(Date),
        min: PropTypes.instanceOf(Date),
        nowButton: PropTypes.bool,
        steps: PropTypes.shape({
            hour: PropTypes.number,
            minute: PropTypes.number,
            second: PropTypes.number
        }),
        smoothScroll: PropTypes.bool,
        tabIndex: PropTypes.number,
        value: PropTypes.instanceOf(Date)
    };
    TimeSelector.defaultProps = {
        value: null,
        disabled: false,
        nowButton: true,
        cancelButton: true,
        format: 't',
        min: MIN_TIME,
        max: MAX_TIME,
        steps: {}
    };
    return TimeSelector;
}(React.Component));
export { TimeSelector };
registerForIntl(TimeSelector);
//# sourceMappingURL=TimeSelector.js.map